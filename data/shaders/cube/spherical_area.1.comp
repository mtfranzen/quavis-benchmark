#version 450
// image settings
#define WIDTH 256 // each work item covers a patch of size (W/N)x(H/M)
#define HEIGHT 256

// local dimensions
#define N_LOCAL 16 // the number of local work items on the x-axis

// constants
#define PI 3.1415926
#define R_MIN 0.001
#define R_MAX 10000.0
#define CHUNKSIZE 16 // WIDTH / N_LOCAL
#define INVHEIGHTPI 0.04908738521234052 // PI / HEIGHT

layout (local_size_x = N_LOCAL, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, rg32f) uniform readonly image2D inputImage0;
layout (binding = 1, rg32f) uniform readonly image2D inputImage1;
layout (binding = 2, rg32f) uniform readonly image2D inputImage2;
layout (binding = 3, rg32f) uniform readonly image2D inputImage3;
layout (binding = 4, rg32f) uniform readonly image2D inputImage4;
layout (binding = 5, rg32f) uniform readonly image2D inputImage5;

layout (binding = 6) buffer outputBuffer {
  float isovist;
};
layout (binding = 7) buffer tempBuffer {
  float tmp_global[];
};

shared float tmp_local[N_LOCAL];

float linearDepth(float depthSample) {
    depthSample = 2.0 * depthSample - 1.0;
    float zLinear = 2.0 * R_MIN * R_MAX / (R_MAX + R_MIN - depthSample * (R_MAX - R_MIN));
    return zLinear;
}

void main()
{
  float weight = 4.0/3.0*PI*R_MAX*R_MAX/(6*WIDTH*HEIGHT);

  // compute sum per item
  uint xpos = gl_LocalInvocationID.x * CHUNKSIZE;
  float tmp = 0.0;
  for (uint x = xpos; x < xpos + CHUNKSIZE; x++) {
    float tmp2 = imageLoad(inputImage0, ivec2(x, gl_WorkGroupID.x)).x;
    tmp2 += imageLoad(inputImage1, ivec2(x, gl_WorkGroupID.x)).x;
    tmp2 += imageLoad(inputImage2, ivec2(x, gl_WorkGroupID.x)).x;
    tmp2 += imageLoad(inputImage3, ivec2(x, gl_WorkGroupID.x)).x;
    tmp2 += imageLoad(inputImage4, ivec2(x, gl_WorkGroupID.x)).x;
    tmp2 += imageLoad(inputImage5, ivec2(x, gl_WorkGroupID.x)).x;
    tmp += tmp2;
  }
  tmp_local[gl_LocalInvocationID.x] = tmp*weight;
  barrier();

  // group sum
  for (uint stride = N_LOCAL >> 1; stride > 0; stride >>= 1) {
    if (gl_LocalInvocationID.x < stride) {
      tmp_local[gl_LocalInvocationID.x] += tmp_local[gl_LocalInvocationID.x + stride];
    }
    barrier();
  }

  if (gl_LocalInvocationID.x == 0) {
    tmp_global[gl_WorkGroupID.x] = tmp_local[0];
  }
}
